!function(_){var t={};function s(n){if(t[n])return t[n].exports;var e=t[n]={i:n,l:!1,exports:{}};return _[n].call(e.exports,e,e.exports,s),e.l=!0,e.exports}s.m=_,s.c=t,s.d=function(_,t,n){s.o(_,t)||Object.defineProperty(_,t,{enumerable:!0,get:n})},s.r=function(_){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(_,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(_,"__esModule",{value:!0})},s.t=function(_,t){if(1&t&&(_=s(_)),8&t)return _;if(4&t&&"object"==typeof _&&_&&_.__esModule)return _;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:_}),2&t&&"string"!=typeof _)for(var e in _)s.d(n,e,function(t){return _[t]}.bind(null,e));return n},s.n=function(_){var t=_&&_.__esModule?function(){return _.default}:function(){return _};return s.d(t,"a",t),t},s.o=function(_,t){return Object.prototype.hasOwnProperty.call(_,t)},s.p="",s(s.s=0)}([function(_,t,s){"use strict";s.r(t);const n=[];class e{constructor(){this._bvh_parent=null,this._bvh_branch=!0,this._bvh_left=null,this._bvh_right=null,this._bvh_sort=0,this._bvh_min_x=0,this._bvh_min_y=0,this._bvh_max_x=0,this._bvh_max_y=0}static getBranch(){return n.length?n.pop():new e}static releaseBranch(_){n.push(_)}static sortBranches(_,t){return _.sort>t.sort?-1:1}}class i{constructor(){this._hierarchy=null,this._bodies=[],this._dirty_branches=[]}insert(_,t=!1){if(!t){const t=_._bvh;if(t&&t!==this)throw new Error("Body belongs to another collision system");_._bvh=this,this._bodies.push(_)}const s=_._polygon,n=_.x,i=_.y;s&&(_._dirty_coords||_.x!==_._x||_.y!==_._y||_.angle!==_._angle||_.scale_x!==_._scale_x||_.scale_y!==_._scale_y)&&_._calculateCoords();const r=_._bvh_padding,h=s?0:_.radius*_.scale,o=(s?_._min_x:n-h)-r,l=(s?_._min_y:i-h)-r,a=(s?_._max_x:n+h)+r,c=(s?_._max_y:i+h)+r;_._bvh_min_x=o,_._bvh_min_y=l,_._bvh_max_x=a,_._bvh_max_y=c;let b=this._hierarchy,v=0;if(b)for(;;){if(!b._bvh_branch){const t=b._bvh_parent,s=b._bvh_min_x,n=b._bvh_min_y,i=b._bvh_max_x,r=b._bvh_max_y,h=b._bvh_parent=_._bvh_parent=e.getBranch();h._bvh_parent=t,h._bvh_left=b,h._bvh_right=_,h._bvh_sort=v++,h._bvh_min_x=o<s?o:s,h._bvh_min_y=l<n?l:n,h._bvh_max_x=a>i?a:i,h._bvh_max_y=c>r?c:r,t?t._bvh_left===b?t._bvh_left=h:t._bvh_right=h:this._hierarchy=h;break}{const _=b._bvh_left,t=_._bvh_min_y,s=_._bvh_max_x,n=_._bvh_max_y,e=o<_._bvh_min_x?o:_._bvh_min_x,i=l<t?l:t,r=a>s?a:s,h=c>n?c:n,u=(r-e)*(h-i)-(s-_._bvh_min_x)*(n-t),y=b._bvh_right,x=y._bvh_min_x,m=y._bvh_min_y,d=y._bvh_max_x,f=y._bvh_max_y,p=o<x?o:x,g=l<m?l:m,w=a>d?a:d,P=c>f?c:f,M=(w-p)*(P-g)-(d-x)*(f-m);b._bvh_sort=v++,b._bvh_min_x=e<p?e:p,b._bvh_min_y=i<g?i:g,b._bvh_max_x=r>w?r:w,b._bvh_max_y=h>P?h:P,b=u<=M?_:y}}else this._hierarchy=_}remove(_,t=!1){if(!t){const t=_._bvh;if(t&&t!==this)throw new Error("Body belongs to another collision system");_._bvh=null,this._bodies.splice(this._bodies.indexOf(_),1)}if(this._hierarchy===_)return void(this._hierarchy=null);const s=_._bvh_parent,n=s._bvh_parent,i=s._bvh_left,r=i===_?s._bvh_right:i;if(r._bvh_parent=n,r._bvh_branch&&(r._bvh_sort=s._bvh_sort),n){n._bvh_left===s?n._bvh_left=r:n._bvh_right=r;let _=n;for(;_;){const t=_._bvh_left,s=t._bvh_min_x,n=t._bvh_min_y,e=t._bvh_max_x,i=t._bvh_max_y,r=_._bvh_right,h=r._bvh_min_x,o=r._bvh_min_y,l=r._bvh_max_x,a=r._bvh_max_y;_._bvh_min_x=s<h?s:h,_._bvh_min_y=n<o?n:o,_._bvh_max_x=e>l?e:l,_._bvh_max_y=i>a?i:a,_=_._bvh_parent}}else this._hierarchy=r;e.releaseBranch(s)}update(){const _=this._bodies,t=_.length;for(let s=0;s<t;++s){const t=_[s];let n=!1;if(n||t.padding===t._bvh_padding||(t._bvh_padding=t.padding,n=!0),!n){const _=t._polygon;_&&(t._dirty_coords||t.x!==t._x||t.y!==t._y||t.angle!==t._angle||t.scale_x!==t._scale_x||t.scale_y!==t._scale_y)&&t._calculateCoords();const s=t.x,e=t.y,i=_?0:t.radius*t.scale,r=_?t._min_x:s-i,h=_?t._min_y:e-i,o=_?t._max_x:s+i,l=_?t._max_y:e+i;n=r<t._bvh_min_x||h<t._bvh_min_y||o>t._bvh_max_x||l>t._bvh_max_y}n&&(this.remove(t,!0),this.insert(t,!0))}}potentials(_){const t=[],s=_._bvh_min_x,n=_._bvh_min_y,e=_._bvh_max_x,i=_._bvh_max_y;let r=this._hierarchy,h=!0;if(!r||!r._bvh_branch)return t;for(;r;){if(h){h=!1;let _=r._bvh_branch?r._bvh_left:null;for(;_&&_._bvh_max_x>=s&&_._bvh_max_y>=n&&_._bvh_min_x<=e&&_._bvh_min_y<=i;)r=_,_=r._bvh_branch?r._bvh_left:null}const o=r._bvh_branch,l=o?r._bvh_right:null;if(l&&l._bvh_max_x>s&&l._bvh_max_y>n&&l._bvh_min_x<e&&l._bvh_min_y<i)r=l,h=!0;else{o||r===_||t.push(r);let s=r._bvh_parent;if(!s)break;for(;s&&s._bvh_right===r;)r=s,s=r._bvh_parent;r=s}}return t}draw(_){const t=this._bodies,s=t.length;for(let n=0;n<s;++n)t[n].draw(_)}drawBVH(_){let t=this._hierarchy,s=!0;for(;t;){if(s){s=!1;let _=t._bvh_branch?t._bvh_left:null;for(;_;)t=_,_=t._bvh_branch?t._bvh_left:null}const n=t._bvh_branch,e=t._bvh_min_x,i=t._bvh_min_y,r=t._bvh_max_x,h=t._bvh_max_y,o=n?t._bvh_right:null;if(_.moveTo(e,i),_.lineTo(r,i),_.lineTo(r,h),_.lineTo(e,h),_.lineTo(e,i),o)t=o,s=!0;else{let _=t._bvh_parent;if(!_)break;for(;_&&_._bvh_right===t;)t=_,_=t._bvh_parent;t=_}}}}class r{constructor(){this.collision=!1,this.a=null,this.b=null,this.a_in_b=!1,this.b_in_a=!1,this.overlap=0,this.overlap_x=0,this.overlap_y=0}}function h(_,t,s=null,n=!0){const e=_._polygon,i=t._polygon;let r=!1;return s&&(s.a=_,s.b=t,s.a_in_b=!0,s.b_in_a=!0,s.overlap=null,s.overlap_x=0,s.overlap_y=0),e&&(_._dirty_coords||_.x!==_._x||_.y!==_._y||_.angle!==_._angle||_.scale_x!==_._scale_x||_.scale_y!==_._scale_y)&&_._calculateCoords(),i&&(t._dirty_coords||t.x!==t._x||t.y!==t._y||t.angle!==t._angle||t.scale_x!==t._scale_x||t.scale_y!==t._scale_y)&&t._calculateCoords(),n&&!function(_,t){const s=_._polygon,n=s?0:_.x,e=s?0:_.y,i=s?0:_.radius*_.scale,r=s?_._min_x:n-i,h=s?_._min_y:e-i,o=s?_._max_x:n+i,l=s?_._max_y:e+i,a=t._polygon,c=a?0:t.x,b=a?0:t.y,v=a?0:t.radius*t.scale,u=a?t._min_x:c-v,y=a?t._min_y:b-v,x=a?t._max_x:c+v,m=a?t._max_y:b+v;return r<x&&h<m&&o>u&&l>y}(_,t)||(e&&_._dirty_normals&&_._calculateNormals(),i&&t._dirty_normals&&t._calculateNormals(),r=e&&i?function(_,t,s=null){const n=_._coords.length,e=t._coords.length;if(2===n&&2===e){const n=_._coords,e=t._coords;return s&&(s.overlap=0),n[0]===e[0]&&n[1]===e[1]}const i=_._coords,r=t._coords,h=_._normals,o=t._normals;if(n>2)for(let _=0,t=1;_<n;_+=2,t+=2)if(l(i,r,h[_],h[t],s))return!1;if(e>2)for(let _=0,t=1;_<e;_+=2,t+=2)if(l(i,r,o[_],o[t],s))return!1;return!0}(_,t,s):e?o(_,t,s,!1):i?o(t,_,s,!0):function(_,t,s=null){const n=_.radius*_.scale,e=t.radius*t.scale,i=t.x-_.x,r=t.y-_.y,h=n+e,o=i*i+r*r;if(o>h*h)return!1;if(s){const _=Math.sqrt(o);s.a_in_b=n<=e&&_<=e-n,s.b_in_a=e<=n&&_<=n-e,s.overlap=h-_,s.overlap_x=i/_,s.overlap_y=r/_}return!0}(_,t,s)),s&&(s.collision=r),r}function o(_,t,s=null,n=!1){const e=_._coords,i=_._edges,r=_._normals,h=t.x,o=t.y,l=t.radius*t.scale,a=2*l,c=l*l,b=e.length;let v=!0,u=!0,y=null,x=0,m=0;if(2===b){const _=h-e[0],t=o-e[1],n=_*_+t*t;if(n>c)return!1;if(s){const s=Math.sqrt(n);y=l-s,x=_/s,m=t/s,u=!1}}else for(let _=0,t=1;_<b;_+=2,t+=2){const n=h-e[_],d=o-e[t],f=i[_],p=i[t],g=n*f+d*p,w=g<0?-1:g>f*f+p*p?1:0;let P=!1,M=0,T=0,B=0;if(s&&v&&n*n+d*d>c&&(v=!1),w){const t=-1===w,r=t?0===_?b-2:_-2:_===b-2?0:_+2,a=r+1,v=h-e[r],y=o-e[a],x=i[r],m=i[a],f=v*x+y*m;if((f<0?-1:f>x*x+m*m?1:0)===-w){const _=t?n:v,e=t?d:y,i=_*_+e*e;if(i>c)return!1;if(s){const t=Math.sqrt(i);P=!0,M=l-t,T=_/t,B=e/t,u=!1}}}else{const e=r[_],i=r[t],h=n*e+d*i,o=h<0?-h:h;if(h>0&&o>l)return!1;s&&(P=!0,M=l-h,T=e,B=i,(u&&h>=0||M<a)&&(u=!1))}P&&(null===y||y>M)&&(y=M,x=T,m=B)}return s&&(s.a_in_b=n?u:v,s.b_in_a=n?v:u,s.overlap=y,s.overlap_x=n?-x:x,s.overlap_y=n?-m:m),!0}function l(_,t,s,n,e=null){const i=_.length,r=t.length;if(!i||!r)return!0;let h=null,o=null,l=null,a=null;for(let t=0,e=1;t<i;t+=2,e+=2){const i=_[t]*s+_[e]*n;(null===h||h>i)&&(h=i),(null===o||o<i)&&(o=i)}for(let _=0,e=1;_<r;_+=2,e+=2){const i=t[_]*s+t[e]*n;(null===l||l>i)&&(l=i),(null===a||a<i)&&(a=i)}if(h>a||o<l)return!0;if(e){let _=0;if(h<l)if(e.a_in_b=!1,o<a)_=o-l,e.b_in_a=!1;else{const t=o-l,s=a-h;_=t<s?t:-s}else if(e.b_in_a=!1,o>a)_=h-a,e.a_in_b=!1;else{const t=o-l,s=a-h;_=t<s?t:-s}const t=e.overlap,i=_<0?-_:_;if(null===t||t>i){const t=_<0?-1:1;e.overlap=i,e.overlap_x=s*t,e.overlap_y=n*t}}return!1}class a{constructor(_=0,t=0,s=0){this.x=_,this.y=t,this.padding=s,this._circle=!1,this._polygon=!1,this._point=!1,this._bvh=null,this._bvh_parent=null,this._bvh_branch=!1,this._bvh_padding=s,this._bvh_min_x=0,this._bvh_min_y=0,this._bvh_max_x=0,this._bvh_max_y=0}collides(_,t=null,s=!0){return h(this,_,t,s)}potentials(){const _=this._bvh;if(null===_)throw new Error("Body does not belong to a collision system");return _.potentials(this)}remove(){const _=this._bvh;_&&_.remove(this,!1)}createResult(){return new r}static createResult(){return new r}}class c extends a{constructor(_=0,t=0,s=0,n=1,e=0){super(_,t,e),this.radius=s,this.scale=n}draw(_){const t=this.x,s=this.y,n=this.radius*this.scale;_.moveTo(t+n,s),_.arc(t,s,n,0,2*Math.PI)}}class b extends a{constructor(_=0,t=0,s=[],n=0,e=1,i=1,r=0){super(_,t,r),this.angle=n,this.scale_x=e,this.scale_y=i,this._polygon=!0,this._x=_,this._y=t,this._angle=n,this._scale_x=e,this._scale_y=i,this._min_x=0,this._min_y=0,this._max_x=0,this._max_y=0,this._points=null,this._coords=null,this._edges=null,this._normals=null,this._dirty_coords=!0,this._dirty_normals=!0,b.prototype.setPoints.call(this,s)}draw(_){(this._dirty_coords||this.x!==this._x||this.y!==this._y||this.angle!==this._angle||this.scale_x!==this._scale_x||this.scale_y!==this._scale_y)&&this._calculateCoords();const t=this._coords;if(2===t.length)_.moveTo(t[0],t[1]),_.arc(t[0],t[1],1,0,2*Math.PI);else{_.moveTo(t[0],t[1]);for(let s=2;s<t.length;s+=2)_.lineTo(t[s],t[s+1]);t.length>4&&_.lineTo(t[0],t[1])}}setPoints(_){const t=_.length;this._points=new Float64Array(2*t),this._coords=new Float64Array(2*t),this._edges=new Float64Array(2*t),this._normals=new Float64Array(2*t);const s=this._points;for(let n=0,e=0,i=1;n<t;++n,e+=2,i+=2){const t=_[n];s[e]=t[0],s[i]=t[1]}this._dirty_coords=!0}_calculateCoords(){const _=this.x,t=this.y,s=this.angle,n=this.scale_x,e=this.scale_y,i=this._points,r=this._coords,h=i.length;let o,l,a,c;for(let b=0,v=1;b<h;b+=2,v+=2){let h=i[b]*n,u=i[v]*e;if(s){const _=Math.cos(s),t=Math.sin(s),n=h;h=n*_-u*t,u=n*t+u*_}h+=_,u+=t,r[b]=h,r[v]=u,0===b?(o=l=h,a=c=u):(h<o?o=h:h>l&&(l=h),u<a?a=u:u>c&&(c=u))}this._x=_,this._y=t,this._angle=s,this._scale_x=n,this._scale_y=e,this._min_x=o,this._min_y=a,this._max_x=l,this._max_y=c,this._dirty_coords=!1,this._dirty_normals=!0}_calculateNormals(){const _=this._coords,t=this._edges,s=this._normals,n=_.length;for(let e=0,i=1;e<n;e+=2,i+=2){const r=e+2<n?e+2:0,h=_[r]-_[e],o=_[r+1]-_[i],l=h||o?Math.sqrt(h*h+o*o):0;t[e]=h,t[i]=o,s[e]=l?o/l:0,s[i]=l?-h/l:0}this._dirty_normals=!1}}class v extends b{constructor(_=0,t=0,s=0){super(_,t,[[0,0]],0,1,1,s),this._point=!0}}v.prototype.setPoints=void 0;const u={Collisions:class{constructor(){this._bvh=new i}createCircle(_=0,t=0,s=0,n=1,e=0){const i=new c(_,t,s,n,e);return this._bvh.insert(i),i}createPolygon(_=0,t=0,s=[[0,0]],n=0,e=1,i=1,r=0){const h=new b(_,t,s,n,e,i,r);return this._bvh.insert(h),h}createPoint(_=0,t=0,s=0){const n=new v(_,t,s);return this._bvh.insert(n),n}createResult(){return new r}static createResult(){return new r}insert(..._){for(const t of _)this._bvh.insert(t,!1);return this}remove(..._){for(const t of _)this._bvh.remove(t,!1);return this}update(){return this._bvh.update(),this}draw(_){return this._bvh.draw(_)}drawBVH(_){return this._bvh.drawBVH(_)}potentials(_){return this._bvh.potentials(_)}collides(_,t,s=null,n=!0){return h(_,t,s,n)}},Result:r,Circle:c,Polygon:b,Point:v};module.exports=u}]);