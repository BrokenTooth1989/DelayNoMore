syntax = "proto3";
option go_package = "battle_srv/protos"; // here "./" corresponds to the "--go_out" value in "protoc" command 

package protos;
import "geometry.proto"; // The import path here is only w.r.t. the proto file, not the Go package.

message PlayerDownsync {
  int32 id = 1;
  int32 virtualGridX = 2; 
  int32 virtualGridY = 3; 
  int32 dirX = 4;
  int32 dirY = 5; // "dirX" and "dirY" determines character facing  
  int32 velX = 6; 
  int32 velY = 7; // "velX" and "velY" is used to record the accumulated effect by accelerations (including gravity)
  int32 speed = 8; // this is the instantaneous scalar attribute of a character, different from but will be accounted in "velX" and "velY" 
  int32 battleState = 9;
  int32 joinIndex = 10;
  double colliderRadius = 11;
  bool removed = 12;
  int32 score = 13;
  int32 lastMoveGmtMillis = 14;
  int32 framesToRecover = 15;
  int32 hp = 16;
  int32 maxHp = 17;
  int32 characterState = 18;
  bool inAir = 19; // by design a standalone field only inferred by the collision result of "applyInputFrameDownsyncDynamicsOnSingleRenderFrame" instead of "characterState", because we need check the transition for "characterState" from this field, i.e. "inAir (prev -> curr)"  

  string name = 20;
  string displayName = 21;
  string avatar = 22;
}

message InputFrameDecoded {
  int32 dx = 1;
  int32 dy = 2;
  int32 btnALevel = 3;
  int32 btnBLevel = 4;
}

message InputFrameUpsync {
  int32 inputFrameId = 1;
  uint64 encoded = 2;
}

message InputFrameDownsync {
  int32 inputFrameId = 1;
  repeated uint64 inputList = 2; // Indexed by "joinIndex", we try to compress the "single player input" into 1 word (64-bit for 64-bit Golang runtime) because atomic compare-and-swap only works on 1 word. Although CAS on custom struct is possible in Golang 1.19 https://pkg.go.dev/sync/atomic@go1.19.1#Value.CompareAndSwap, using a single word is still faster whenever possible. 
  uint64 confirmedList = 3; // Indexed by "joinIndex", same compression concern as above
}

message HeartbeatUpsync {
  int64 clientTimestamp = 1;     
}

message WsReq {
  int32 msgId = 1;
  int32 playerId = 2;
  int32 act = 3;    
  int32 joinIndex = 4;
  int32 ackingFrameId = 5;
  int32 ackingInputFrameId = 6;
  repeated InputFrameUpsync inputFrameUpsyncBatch = 7; 
  HeartbeatUpsync hb = 8; 
}

message WsResp {
  int32 ret = 1;
  int32 echoedMsgId = 2;    
  int32 act = 3; 
  RoomDownsyncFrame rdf = 4; 
  repeated InputFrameDownsync inputFrameDownsyncBatch = 5;
  BattleColliderInfo bciFrame = 6; 
}

message InputsBufferSnapshot {
  int32 refRenderFrameId = 1;    
  uint64 unconfirmedMask = 2;
  repeated InputFrameDownsync toSendInputFrameDownsyncs = 3;
  bool shouldForceResync = 4;
}

message MeleeBullet { 
  // Jargon reference https://www.thegamer.com/fighting-games-frame-data-explained/
  // ALL lengths are in world coordinate

  // for offender  
  int32 battleLocalId = 1;
  int32 startupFrames = 2; 
  int32 activeFrames = 3;  
  int32 recoveryFrames = 4;
  int32 recoveryFramesOnBlock = 5; 
  int32 recoveryFramesOnHit = 6;  
  double hitboxOffset = 7;  
  int32 originatedRenderFrameId = 8; 

  // for defender
  int32 hitStunFrames = 9; 
  int32 blockStunFrames = 10; 
  double pushback = 11;  

  int32 releaseTriggerType = 12; // 1: rising-edge, 2: falling-edge  
  int32 damage = 13;   

  int32 offenderJoinIndex = 14;    
  int32 offenderPlayerId = 15;    

  double hitboxSizeX = 16; 
  double hitboxSizeY = 17;

  double selfMoveforwardX = 18;  
  double selfMoveforwardY = 19;  
} 

message BattleColliderInfo {
  string stageName = 1;
  int32 stageDiscreteW = 2;
  int32 stageDiscreteH = 3;
  int32 stageTileW = 4;
  int32 stageTileH = 5;

  int32 intervalToPing        = 6;
  int32 willKickIfInactiveFor = 7;
  int32 boundRoomId           = 8;
  int32 battleDurationFrames  = 9;
  int64 battleDurationNanos   = 10;
  int32 serverFps             = 11;
  int32 inputDelayFrames      = 12; // in the count of render frames
  uint32 inputScaleFrames     = 13; // inputDelayedAndScaledFrameId = ((originalFrameId - InputDelayFrames) >> InputScaleFrames)
  int32 nstDelayFrames        = 14; // network-single-trip delay in the count of render frames, proposed to be (InputDelayFrames >> 1) because we expect a round-trip delay to be exactly "InputDelayFrames"
  int32 inputFrameUpsyncDelayTolerance = 15;  
  int32 maxChasingRenderFramesPerUpdate = 16;
  int32 playerBattleState = 17;
  double rollbackEstimatedDtMillis = 18;
  int64 rollbackEstimatedDtNanos = 19;
 
  double worldToVirtualGridRatio = 20;
  double virtualGridToWorldRatio = 21;

  int32 spAtkLookupFrames = 22;
  int32 renderCacheSize = 23;

  map<int32, MeleeBullet> meleeSkillConfig = 24; // skillId -> skill

  double snapIntoPlatformOverlap = 25; 
  double snapIntoPlatformThreshold = 26; 
  int32 jumpingInitVelY = 27;
  int32 gravityX = 28;
  int32 gravityY = 29;
  int32 collisionMinStep = 30;
}

message RoomDownsyncFrame {
  int32 id = 1;
  repeated PlayerDownsync playersArr = 2;
  int64 countdownNanos = 3;
  repeated MeleeBullet meleeBullets = 4; // I don't know how to mimic inheritance/composition in protobuf by far, thus using an array for each type of bullet as a compromise 
  uint64 backendUnconfirmedMask = 5; // Indexed by "joinIndex", same compression concern as stated in InputFrameDownsync
  bool shouldForceResync = 6;
}
